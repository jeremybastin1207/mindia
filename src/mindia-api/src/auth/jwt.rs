use crate::auth::models::{JwtClaims, UserRole};
use jsonwebtoken::{decode, DecodingKey, Validation};
use mindia_core::AppError;

/// JWT validation for external user service.
#[allow(dead_code)]
pub struct JwtService {
    decoding_key: DecodingKey,
}

#[allow(dead_code)]
impl JwtService {
    /// Create a new JWT service with the given secret
    /// Note: JWT tokens are generated by the external user service
    pub fn new(secret: String) -> Self {
        Self {
            decoding_key: DecodingKey::from_secret(secret.as_bytes()),
        }
    }

    /// Validate and decode a JWT token from the external user service
    /// Uses strict validation with explicit exp and nbf checks
    pub fn validate_token(&self, token: &str) -> Result<JwtClaims, AppError> {
        // Create validation with strict settings
        let mut validation = Validation::default();
        validation.validate_exp = true; // Require expiration time
        validation.validate_nbf = true; // Require "not before" time
        validation.leeway = 0; // No leeway - tokens must be valid at the exact moment
        validation.algorithms = vec![jsonwebtoken::Algorithm::HS256]; // Explicitly require HS256

        let token_data =
            decode::<JwtClaims>(token, &self.decoding_key, &validation).map_err(|e| {
                tracing::debug!("JWT validation failed: {}", e);
                match e.kind() {
                    jsonwebtoken::errors::ErrorKind::ExpiredSignature => {
                        AppError::Unauthorized("Token has expired".to_string())
                    }
                    jsonwebtoken::errors::ErrorKind::InvalidIssuer => {
                        AppError::Unauthorized("Invalid token issuer".to_string())
                    }
                    jsonwebtoken::errors::ErrorKind::InvalidSubject => {
                        AppError::Unauthorized("Invalid token subject".to_string())
                    }
                    jsonwebtoken::errors::ErrorKind::ImmatureSignature => {
                        AppError::Unauthorized("Token is not yet valid (nbf)".to_string())
                    }
                    _ => AppError::Unauthorized("Invalid or expired token".to_string()),
                }
            })?;

        Ok(token_data.claims)
    }

    /// Parse user role from string
    pub fn parse_role(role_str: &str) -> Result<UserRole, AppError> {
        match role_str {
            "admin" => Ok(UserRole::Admin),
            "member" => Ok(UserRole::Member),
            "viewer" => Ok(UserRole::Viewer),
            _ => Err(AppError::Unauthorized("Invalid user role".to_string())),
        }
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_validate_invalid_token() {
        let jwt_service = JwtService::new("test_secret_key_12345".to_string());
        let result = jwt_service.validate_token("invalid.token.here");
        assert!(result.is_err());
    }

    #[test]
    fn test_parse_role() {
        assert!(matches!(
            JwtService::parse_role("admin"),
            Ok(UserRole::Admin)
        ));
        assert!(matches!(
            JwtService::parse_role("member"),
            Ok(UserRole::Member)
        ));
        assert!(matches!(
            JwtService::parse_role("viewer"),
            Ok(UserRole::Viewer)
        ));
        assert!(JwtService::parse_role("invalid").is_err());
    }
}
