mod helpers;

use helpers::auth::{get_auth_token, login_user, register_test_user};
use helpers::setup_test_app;

#[tokio::test]
async fn test_register() {
    let app = setup_test_app().await;
    let client = app.client();

    let user = register_test_user(client, None, None, None).await;

    assert!(!user.token.is_empty());
    assert_ne!(user.tenant_id, uuid::Uuid::nil());
    assert_ne!(user.user_id, uuid::Uuid::nil());
}

#[tokio::test]
async fn test_register_duplicate_email() {
    let app = setup_test_app().await;
    let client = app.client();

    // Register first user
    register_test_user(client, Some("duplicate@example.com"), None, None).await;

    // Try to register again with same email
    let response = client
        .post("/api/v0/auth/register")
        .json(&serde_json::json!({
            "organization_name": "Another Org",
            "admin_email": "duplicate@example.com",
            "admin_password": "TestPassword123!",
            "s3_bucket": "test-bucket",
            "s3_region": "us-east-1"
        }))
        .await;

    assert!(response.status_code() >= 400);
}

#[tokio::test]
async fn test_login() {
    let app = setup_test_app().await;
    let client = app.client();

    // Register a user first
    let user = register_test_user(client, None, None, None).await;

    // Login with the same credentials
    let token = login_user(client, &user.email, &user.password).await;

    assert!(!token.is_empty());
}

#[tokio::test]
async fn test_login_invalid_credentials() {
    let app = setup_test_app().await;
    let client = app.client();

    // Register a user
    register_test_user(client, Some("test@example.com"), Some("Password123!"), None).await;

    // Try to login with wrong password
    let response = client
        .post("/api/v0/auth/login")
        .json(&serde_json::json!({
            "email": "test@example.com",
            "password": "WrongPassword123!"
        }))
        .await;

    assert_eq!(response.status_code(), 401);
}

#[tokio::test]
async fn test_me_endpoint() {
    let app = setup_test_app().await;
    let client = app.client();

    // Register and get token
    let user = register_test_user(client, None, None, None).await;

    // Call /api/auth/me
    let response = client
        .get("/api/v0/auth/me")
        .add_header("Authorization", format!("Bearer {}", user.token))
        .await;

    assert_eq!(response.status_code(), 200);

    let me_data: serde_json::Value = response.json();
    assert_eq!(me_data["id"], serde_json::json!(user.user_id));
    assert_eq!(me_data["email"], serde_json::json!(user.email));
}

#[tokio::test]
async fn test_me_endpoint_unauthorized() {
    let app = setup_test_app().await;
    let client = app.client();

    // Call /api/auth/me without token
    let response = client.get("/api/v0/auth/me").await;

    assert_eq!(response.status_code(), 401);
}

#[tokio::test]
async fn test_me_endpoint_invalid_token() {
    let app = setup_test_app().await;
    let client = app.client();

    // Call /api/auth/me with invalid token
    let response = client
        .get("/api/v0/auth/me")
        .add_header("Authorization", "Bearer invalid-token")
        .await;

    assert_eq!(response.status_code(), 401);
}

/// Test JWT expiration validation (exp claim)
/// Tokens with exp in the past should be rejected
#[tokio::test]
async fn test_jwt_expired_token_rejected() {
    let app = setup_test_app().await;
    let client = app.client();

    // Register a user to get a valid token
    let user = register_test_user(client, None, None, None).await;

    // Note: Since JWT tokens are generated by external service and have a 24-hour expiry,
    // we can't easily create an expired token for testing without mocking.
    // This test documents the expected behavior: expired tokens should be rejected.
    // In a real test environment with token generation, you would:
    // 1. Generate a token with exp in the past
    // 2. Attempt to use it
    // 3. Verify it's rejected with "Token has expired" error

    // For now, test that valid tokens work (inverse test)
    let valid_response = client
        .get("/api/v0/auth/me")
        .add_header("Authorization", format!("Bearer {}", user.token))
        .await;

    assert_eq!(
        valid_response.status_code(),
        200,
        "Valid token should be accepted"
    );

    // Test that invalid tokens are rejected (which includes expired)
    let invalid_response = client
        .get("/api/v0/auth/me")
        .add_header("Authorization", "Bearer expired.token.here")
        .await;

    assert_eq!(
        invalid_response.status_code(),
        401,
        "Invalid/expired token should be rejected"
    );
}

/// Test JWT "not before" validation (nbf claim)
/// Tokens with nbf in the future should be rejected
#[tokio::test]
async fn test_jwt_not_yet_valid_token_rejected() {
    let app = setup_test_app().await;
    let client = app.client();

    // Since tokens are generated externally, we can't easily create a token with nbf in the future
    // This test documents expected behavior: tokens with nbf > current_time should be rejected
    // with "Token is not yet valid (nbf)" error

    // Test that tokens work when valid (inverse test)
    let user = register_test_user(client, None, None, None).await;
    let response = client
        .get("/api/v0/auth/me")
        .add_header("Authorization", format!("Bearer {}", user.token))
        .await;

    assert_eq!(
        response.status_code(),
        200,
        "Valid token should be accepted"
    );
}

/// Test JWT validation with no leeway (leeway = 0)
/// Tokens exactly at expiration boundary should fail (no grace period)
#[tokio::test]
async fn test_jwt_no_leeway() {
    let app = setup_test_app().await;
    let client = app.client();

    // With leeway = 0, tokens must be valid at the exact moment of validation
    // No grace period is allowed for clock skew or timing issues
    
    // Test that valid tokens work
    let user = register_test_user(client, None, None, None).await;
    let response = client
        .get("/api/v0/auth/me")
        .add_header("Authorization", format!("Bearer {}", user.token))
        .await;

    assert_eq!(
        response.status_code(),
        200,
        "Valid token should be accepted even with leeway=0"
    );

    // Note: Testing exact boundary failure would require:
    // 1. Token with exp = current_time exactly
    // 2. Attempt to validate
    // 3. Should fail (no leeway allowed)
    // This is difficult without mocking time or token generation
}

/// Test JWT algorithm validation - only HS256 should be accepted
#[tokio::test]
async fn test_jwt_invalid_algorithm() {
    let app = setup_test_app().await;
    let client = app.client();

    // Tokens signed with algorithms other than HS256 should be rejected
    // This includes RS256, ES256, etc.
    
    // Since we can't easily generate tokens with different algorithms without the signing key,
    // we test that invalid tokens (which could include wrong algorithm) are rejected
    let response = client
        .get("/api/v0/auth/me")
        .add_header("Authorization", "Bearer invalid.algorithm.token")
        .await;

    assert_eq!(
        response.status_code(),
        401,
        "Token with invalid algorithm should be rejected"
    );
}

/// Test JWT invalid signature is rejected
#[tokio::test]
async fn test_jwt_invalid_signature() {
    let app = setup_test_app().await;
    let client = app.client();

    // Tokens with invalid signatures should be rejected
    // We can test this by creating a token with correct format but wrong signature
    
    // Create a token-like string with invalid signature
    let invalid_token = "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiaWF0IjoxNTE2MjM5MDIyfQ.invalid_signature_here";
    
    let response = client
        .get("/api/v0/auth/me")
        .add_header("Authorization", format!("Bearer {}", invalid_token))
        .await;

    assert_eq!(
        response.status_code(),
        401,
        "Token with invalid signature should be rejected"
    );
}

/// Test JWT missing claims are handled properly
#[tokio::test]
async fn test_jwt_missing_claims() {
    let app = setup_test_app().await;
    let client = app.client();

    // Tokens missing required claims (like exp, nbf, sub, tenant_id) should be rejected
    // Test with invalid/malformed tokens
    
    let malformed_token = "not.a.valid.jwt.token";
    
    let response = client
        .get("/api/v0/auth/me")
        .add_header("Authorization", format!("Bearer {}", malformed_token))
        .await;

    assert_eq!(
        response.status_code(),
        401,
        "Token with missing claims should be rejected"
    );
}

/// Test JWT token with tenant context
#[tokio::test]
async fn test_jwt_token_with_tenant_context() {
    let app = setup_test_app().await;
    let client = app.client();

    // Valid JWT tokens should contain tenant_id and be usable
    let user = register_test_user(client, None, None, None).await;

    // Use token to access tenant-scoped resource
    let response = client
        .get("/api/v0/images")
        .add_header("Authorization", format!("Bearer {}", user.token))
        .await;

    // Should succeed (even if empty list) - token is valid and tenant context is set
    assert!(
        response.status_code() == 200 || response.status_code() == 404,
        "Valid token with tenant context should allow access to tenant resources"
    );
}